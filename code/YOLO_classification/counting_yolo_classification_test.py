# -*- coding: utf-8 -*-
"""「YOLO_SEALION」的簡單版

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12RPfyrxKb9BWD6cwYZKOmbxOrMqcGuip
"""

!pip install ultralytics
!pip install pandas
!pip install torch
!pip install tqdm

from google.colab import drive
drive.mount('/content/drive')

import os
import pandas as pd
import torch
from ultralytics import YOLO
from pathlib import Path
from tqdm import tqdm
from collections import defaultdict
import logging
import matplotlib.pyplot as plt
import zipfile
# 設定日誌
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

print(f"PyTorch版本: {torch.__version__}")
print(f"CUDA可用: {torch.cuda.is_available()}")
if torch.cuda.is_available():
    print(f"GPU: {torch.cuda.get_device_name(0)}")

from google.colab import drive
drive.mount('/content/drive')

import os
import pandas as pd
import torch
from ultralytics import YOLO
from pathlib import Path
from tqdm import tqdm
from collections import defaultdict
import logging
import matplotlib.pyplot as plt
import zipfile
# 設定日誌
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

print(f"PyTorch版本: {torch.__version__}")
print(f"CUDA可用: {torch.cuda.is_available()}")
if torch.cuda.is_available():
    print(f"GPU: {torch.cuda.get_device_name(0)}")

#%%
# 海獅類別定義 (5個類別)
SEALION_CLASSES = {
    0: 'class_0_Adult Males',
    1: 'class_1_Subadult Males',
    2: 'class_2_Adult Females',
    3: 'class_3_Juveniles',
    4: 'class_4_Pups'
}

# 設定檔案路徑
model_path = '/content/drive/MyDrive/DL_HW/final/yolo11x-cls_sealion_60.pt'  # 您的模型路徑

# 測試資料選項 - 選擇其中一種
# 選項1: 直接使用資料夾
#image_folder = '/content/drive/MyDrive/preprocessed_images'   # 100x100圖片資料夾

# 選項2: 使用ZIP檔案 (如果有的話會自動解壓縮)
zip_file_path = '/content/drive/MyDrive/DL_HW/final/Test_Sealion_60.zip'      # ZIP壓縮檔路徑
extract_folder = '/content/Test_Sealion_60'                 # 解壓縮目標資料夾

output_csv = '/content/drive/MyDrive/DL_HW/final/sealion_60_count_results.csv'           # 輸出檔案

# 載入模型
if os.path.exists(model_path):
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = YOLO(model_path)
    print(f"✅ 模型已載入: {model_path}")
    print(f"🖥️ 使用設備: {device}")
else:
    print(f"❌ 找不到模型檔案: {model_path}")
    print("請確保模型檔案在 Google Drive 中")

def extract_zip_file(zip_path, extract_to):
    """解壓縮ZIP檔案"""

    if not os.path.exists(zip_path):
        print(f"❌ ZIP檔案不存在: {zip_path}")
        return False

    try:
        # 建立解壓縮目標資料夾
        os.makedirs(extract_to, exist_ok=True)

        print(f"📦 開始解壓縮: {zip_path}")

        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            # 獲取ZIP檔案資訊
            file_list = zip_ref.namelist()
            total_files = len(file_list)

            print(f"📁 ZIP檔案包含 {total_files} 個檔案")

            # 解壓縮所有檔案
            zip_ref.extractall(extract_to)

            # 統計圖片檔案
            image_extensions = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff'}
            image_count = 0

            for file_name in file_list:
                if any(file_name.lower().endswith(ext) for ext in image_extensions):
                    image_count += 1

            print(f"✅ 解壓縮完成！")
            print(f"📷 找到 {image_count} 張圖片檔案")
            print(f"📁 解壓縮位置: {extract_to}")

            return True

    except Exception as e:
        print(f"❌ 解壓縮失敗: {e}")
        return False

def determine_image_source():
    """決定使用哪種圖片來源"""

    # 檢查是否有ZIP檔案
    if os.path.exists(zip_file_path):
        print(f"🔍 發現ZIP檔案: {zip_file_path}")

        # 檢查是否已經解壓縮過
        if os.path.exists(extract_folder) and os.listdir(extract_folder):
            print(f"📁 解壓縮資料夾已存在且非空: {extract_folder}")

            # 詢問是否重新解壓縮
            print("選項:")
            print("1. 使用現有解壓縮資料夾")
            print("2. 重新解壓縮ZIP檔案")

            # 在Colab中，我們預設使用現有資料夾，除非資料夾為空
            if len(os.listdir(extract_folder)) > 0:
                print("➡️ 使用現有解壓縮資料夾")
                return extract_folder
            else:
                print("➡️ 資料夾為空，重新解壓縮")

        # 解壓縮ZIP檔案
        if extract_zip_file(zip_file_path, extract_folder):
            return extract_folder
        else:
            print("⚠️ ZIP解壓縮失敗，嘗試使用原始資料夾")

    # 檢查原始資料夾
    if os.path.exists(image_folder):
        print(f"📁 使用原始資料夾: {image_folder}")
        return image_folder
    else:
        print(f"❌ 找不到圖片資料夾: {image_folder}")
        return None

def extract_image_id(filename):
    """
    從檔名提取原圖編號

    Args:
        filename: 檔案名稱，格式: {原圖編號}_剩餘後綴.jpg

    Returns:
        原圖編號 (字串)
    """
    # 移除副檔名
    name_without_ext = Path(filename).stem

    # 以第一個底線分割，取第一部分作為原圖編號
    image_id = name_without_ext.split('_')[0]

    return image_id

def collect_image_files(folder_path):
    """收集資料夾中的所有圖片檔案 (包含子資料夾)"""

    folder = Path(folder_path)

    # 支援的圖片副檔名
    supported_extensions = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff'}

    # 收集所有圖片檔案 (包含子資料夾)
    image_files = []

    # 遞歸搜尋所有圖片檔案
    for ext in supported_extensions:
        image_files.extend(folder.rglob(f'*{ext}'))
        image_files.extend(folder.rglob(f'*{ext.upper()}'))

    # 移除重複檔案
    image_files = list(set(image_files))

    return image_files

def predict_and_accumulate(model, image_files):
    """預測所有圖片並累積結果"""

    # 用於累積每個原圖的分類結果
    image_results = defaultdict(lambda: {class_name.replace('class_', ''): 0
                                       for class_name in SEALION_CLASSES.values()})
    image_confidence = defaultdict(list)

    print(f"開始預測 {len(image_files)} 張圖片...")

    # 準備圖片路徑列表
    image_paths = [str(img_path) for img_path in image_files]

    # 批量預測 (更高效)
    try:
        # 改用 stream=True，避免記憶體爆掉
      from more_itertools import chunked

      BATCH_SIZE = 256
      for batch in tqdm(chunked(image_files, BATCH_SIZE), total=len(image_files) // BATCH_SIZE):
          batch_paths = [str(p) for p in batch]
          results = model(batch_paths, stream=True, verbose=False)
          for img_path, result in zip(batch, results):
              # 單張處理

            # 提取原圖編號
            image_id = extract_image_id(img_path.name)

            # 處理預測結果
            if hasattr(result, 'probs') and result.probs is not None:
                class_id = result.probs.top1
                confidence = result.probs.top1conf.item()
                class_name = SEALION_CLASSES.get(class_id, '未知')

                # 簡化類別名稱 (移除 class_ 前綴)
                simplified_class = class_name.replace('class_', '')

                # 累加到對應原圖
                image_results[image_id][simplified_class] += 1
                image_confidence[image_id].append(confidence)

            else:
                logger.warning(f"預測失敗: {img_path.name}")

    except Exception as e:
        print(f"⚠️ 批量預測失敗，改用單張預測: {e}")

        # 如果批量預測失敗，改用單張預測
        for img_path in tqdm(image_files, desc="單張預測進度"):
            try:
                result = model(str(img_path), verbose=False)[0]

                # 提取原圖編號
                image_id = extract_image_id(img_path.name)

                # 處理預測結果
                if hasattr(result, 'probs') and result.probs is not None:
                    class_id = result.probs.top1
                    confidence = result.probs.top1conf.item()
                    class_name = SEALION_CLASSES.get(class_id, '未知')

                    # 簡化類別名稱
                    simplified_class = class_name.replace('class_', '')

                    # 累加到對應原圖
                    image_results[image_id][simplified_class] += 1
                    image_confidence[image_id].append(confidence)

                else:
                    logger.warning(f"預測失敗: {img_path.name}")

            except Exception as e2:
                logger.error(f"預測 {img_path.name} 時出錯: {e2}")

    return image_results, image_confidence

actual_image_folder = determine_image_source()

if actual_image_folder:
    image_files = collect_image_files(actual_image_folder)
    print(f"✅ 最終使用資料夾: {actual_image_folder}")
    print(f"✅ 找到 {len(image_files)} 張圖片")

    # 顯示前10個檔案範例
    print(f"\n前10個檔案範例:")
    for i, img_file in enumerate(image_files[:10]):
        image_id = extract_image_id(img_file.name)
        # 顯示相對路徑
        rel_path = img_file.relative_to(Path(actual_image_folder))
        print(f"  {rel_path} -> 原圖編號: {image_id}")

    if len(image_files) > 10:
        print(f"  ... 還有 {len(image_files) - 10} 張圖片")

    # 檢查檔名格式
    print(f"\n檔名格式檢查:")
    valid_format_count = 0
    for img_file in image_files[:20]:  # 檢查前20個
        if '_' in img_file.stem:
            valid_format_count += 1

    format_ratio = valid_format_count / min(20, len(image_files))
    print(f"  符合格式 ({image_id}_xxx) 的檔案比例: {format_ratio:.1%}")

    if format_ratio < 0.8:
        print("  ⚠️ 警告: 大部分檔案可能不符合預期格式")

else:
    print("❌ 沒有找到可用的圖片來源")
    print("請確保:")
    print("  1. ZIP檔案路徑正確")
    print("  2. 或圖片資料夾路徑正確")
    print("  3. 檔案已上傳到Google Drive")

if 'image_files' in locals() and len(image_files) > 0 and 'model' in locals():
    # 執行預測
    image_results, image_confidence = predict_and_accumulate(model, image_files)

    print(f"✅ 預測完成！")
    print(f"📊 處理了 {len(image_results)} 張原圖")
    print(f"📷 總共預測了 {len(image_files)} 張小圖片")

    # 顯示處理效率
    if len(image_results) > 0:
        avg_images_per_original = len(image_files) / len(image_results)
        print(f"📈 平均每張原圖包含 {avg_images_per_original:.1f} 張小圖片")
else:
    if 'model' not in locals():
        print("❌ 模型未載入，無法執行預測")
    else:
        print("❌ 沒有圖片可預測")

if 'image_results' in locals() and image_results:

    # 建立結果數據
    result_data = []

    for image_id in image_results:
        row = {'image_id': image_id}

        # 添加各類別數量
        total_sealions = 0
        for class_name in ['0_Adult Males', '1_Subadult Males', '2_Adult Females', '3_Juveniles', '4_Pups']:
            count = image_results[image_id][class_name]
            row[class_name] = count
            total_sealions += count

        # 總計和平均信心度
        row['total_sealions'] = total_sealions

        if image_confidence[image_id]:
            row['avg_confidence'] = sum(image_confidence[image_id]) / len(image_confidence[image_id])
        else:
            row['avg_confidence'] = 0.0

        result_data.append(row)

    # 建立 DataFrame 並排序
    results_df = pd.DataFrame(result_data)
    results_df = results_df.sort_values('image_id')

    print(f"✅ 結果 DataFrame 建立完成！")
    print(f"📊 包含 {len(results_df)} 張原圖的統計結果")

else:
    print("❌ 沒有預測結果可處理")

if 'results_df' in locals() and not results_df.empty:

    print(f"=== 預測結果摘要 ===")
    print(f"處理原圖數量: {len(results_df)}")
    print(f"總海獅數量: {results_df['total_sealions'].sum()}")
    print(f"平均每張原圖海獅數: {results_df['total_sealions'].mean():.2f}")
    print(f"平均信心度: {results_df['avg_confidence'].mean():.4f}")

    # 各類別總數統計
    class_columns = ['0_Adult Males', '1_Subadult Males', '2_Adult Females', '3_Juveniles', '4_Pups']
    total_all = results_df['total_sealions'].sum()

    print(f"\n各類別統計:")
    for col in class_columns:
        total = results_df[col].sum()
        percentage = (total / total_all * 100) if total_all > 0 else 0
        print(f"  {col}: {total} ({percentage:.1f}%)")

    # 顯示前10筆結果
    print(f"\n前10筆結果:")
    print(results_df.head(10).to_string(index=False))

else:
    print("❌ 沒有結果可顯示")

if 'results_df' in locals() and not results_df.empty:

    # Prepare class columns (keep in Chinese for data processing)
    class_columns = ['0_Adult Males', '1_Subadult Males', '2_Adult Females', '3_Juveniles', '4_Pups']

    # Mapping for display in English
    class_label_map = {
        '0_成年雄性': '0_Adult Male',
        '1_亞成年雄性': '1_Subadult Male',
        '2_成年雌性': '2_Adult Female',
        '3_幼獸': '3_Juvenile',
        '4_幼崽': '4_Pup'
    }

    fig, axes = plt.subplots(2, 2, figsize=(15, 10))

    # 1. Total count distribution per class
    class_totals = results_df[class_columns].sum()
    labels_pie = [class_label_map.get(c, c) for c in class_totals.index]
    axes[0, 0].pie(class_totals.values, labels=labels_pie, autopct='%1.1f%%')
    axes[0, 0].set_title('Total Distribution per Class')

    # 2. Sealion count per original image
    axes[0, 1].hist(results_df['total_sealions'], bins=20, alpha=0.7, edgecolor='black')
    axes[0, 1].set_title('Number of Sealions per Image')
    axes[0, 1].set_xlabel('Number of Sealions')
    axes[0, 1].set_ylabel('Number of Images')

    # 3. Average confidence distribution
    axes[1, 0].hist(results_df['avg_confidence'], bins=20, alpha=0.7, edgecolor='black')
    axes[1, 0].set_title('Average Confidence Distribution')
    axes[1, 0].set_xlabel('Average Confidence')
    axes[1, 0].set_ylabel('Number of Images')

    # 4. Presence frequency of each class in images
    class_presence = (results_df[class_columns] > 0).sum()
    labels_bar = [class_label_map.get(c, c) for c in class_presence.index]
    axes[1, 1].bar(labels_bar, class_presence.values)
    axes[1, 1].set_title('Class Presence Frequency in Images')
    axes[1, 1].set_xlabel('Class')
    axes[1, 1].set_ylabel('Number of Images with Class Present')
    axes[1, 1].tick_params(axis='x', rotation=45)

    plt.tight_layout()
    plt.savefig('/content/sealion_statistics.png', dpi=150, bbox_inches='tight')
    plt.show()

    print("📊 Statistics chart saved to: /content/sealion_statistics.png")

if 'results_df' in locals() and not results_df.empty:

    # 儲存主要結果
    results_df.to_csv(output_csv, index=False)
    print(f"✅ 結果已儲存至: {output_csv}")

    # 檢查檔案大小
    file_size = os.path.getsize(output_csv) / 1024  # KB
    print(f"📁 檔案大小: {file_size:.2f} KB")

    # 顯示CSV內容預覽
    print(f"\nCSV檔案預覽:")
    print(results_df.head().to_string(index=False))

else:
    print("❌ 沒有結果可儲存")

from google.colab import files

# 下載主要結果檔案
if os.path.exists(output_csv):
    files.download(output_csv)
    print(f"⬇️ 已下載結果檔案: {output_csv}")

# 下載統計圖表
chart_file = '/content/sealion_statistics.png'
if os.path.exists(chart_file):
    files.download(chart_file)
    print(f"⬇️ 已下載統計圖表: {chart_file}")

if 'results_df' in locals() and not results_df.empty:

    print("=== 進階分析 ===")

    # 1. 找出海獅最多的原圖
    max_sealions = results_df.loc[results_df['total_sealions'].idxmax()]
    print(f"\n海獅最多的原圖:")
    print(f"  原圖編號: {max_sealions['image_id']}")
    print(f"  總海獅數: {max_sealions['total_sealions']}")
    print(f"  信心度: {max_sealions['avg_confidence']:.4f}")

    # 2. 找出各類別出現最多的原圖
    class_columns = ['0_Adult Males', '1_Subadult Males', '2_Adult Females', '3_Juveniles', '4_Pups']
    print(f"\n各類別最多的原圖:")
    for col in class_columns:
        if results_df[col].max() > 0:
            max_row = results_df.loc[results_df[col].idxmax()]
            print(f"  {col}: 原圖 {max_row['image_id']} ({max_row[col]} 隻)")

    # 3. 統計分布
    print(f"\n分布統計:")
    print(f"  有海獅的原圖: {(results_df['total_sealions'] > 0).sum()}")
    print(f"  無海獅的原圖: {(results_df['total_sealions'] == 0).sum()}")
    print(f"  最大海獅數: {results_df['total_sealions'].max()}")
    print(f"  信心度中位數: {results_df['avg_confidence'].median():.4f}")

print("\n🎉 簡化海獅分類預測完成！")

if 'image_files' in locals() and len(image_files) > 0:
    test_images = image_files[:2000]  # 測試前20張
    print(f"測試 {len(test_images)} 張圖片...")

    test_class_stats = {}

    for img_path in test_images:
        try:
            result = model(str(img_path), verbose=False)[0]

            if hasattr(result, 'probs') and result.probs is not None:
                class_id = result.probs.top1
                confidence = result.probs.top1conf.item()
                class_name = SEALION_CLASSES.get(class_id, f'未知類別_{class_id}')

                if class_id not in test_class_stats:
                    test_class_stats[class_id] = 0
                test_class_stats[class_id] += 1

                print(f"   {img_path.name}: 類別 {class_id} ({class_name}), 信心度: {confidence:.3f}")
            else:
                print(f"   {img_path.name}: 預測失敗")

        except Exception as e:
            print(f"   {img_path.name}: 錯誤 - {e}")

    print(f"\n快速測試類別統計:")
    for class_id, count in sorted(test_class_stats.items()):
        class_name = SEALION_CLASSES.get(class_id, f'未知類別_{class_id}')
        print(f"   類別 {class_id} ({class_name}): {count} 張")

    # 檢查是否有缺失的類別
    expected_classes = set(range(5))  # 0, 1, 2, 3, 4
    found_classes = set(test_class_stats.keys())
    missing_classes = expected_classes - found_classes

    if missing_classes:
        print(f"\n⚠️ 警告：在測試樣本中沒有發現以下類別: {missing_classes}")
        print("這可能表示：")
        print("1. 模型沒有預測出這些類別")
        print("2. 測試樣本中確實沒有這些類別的圖片")
        print("3. 模型的類別數量與預期不符")
    else:
        print(f"\n✅ 所有5個類別都在測試樣本中被發現")
else:
    print("❌ 沒有圖片可測試")